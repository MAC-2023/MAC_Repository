<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            font-size: 20px;
            background-color: #000;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #miniMap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #fff;
            background-color: rgba(0, 0, 0, 0.5);
        }
        #playerCoords {
            position: absolute;
            top: 170px;
            right: 10px;
            color: #fff;
        }
        #playerAngle {
            position: absolute;
            top: 190px;
            right: 10px;
            color: #fff;
        }
        #collisionText {
            position: absolute;
            top: 210px;
            right: 10px;
            color: #fff;
        }
        #levelText {
            position: absolute;
            top: 230px;
            right: 10px;
            color: #fff;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <button id="startButton">Start Game</button>
    <canvas id="miniMap" width="150" height="150"></canvas>
    <div id="playerCoords"></div>
    <div id="playerAngle"></div>
    <div id="collisionText">Collision: No</div>
    <div id="levelText">Level: 1</div>
    <script>
        // Basic setup
        let scene, camera, renderer, controls;
        const objects = [];
        const enemies = [];
        let currentLevel = 1;

        const mazeWidth = 25; // Updated to 25
        const mazeHeight = 25; // Updated to 25
        const cellSize = 10;

        // Offset variables for fine adjustments
        const X_offset = 5;
        const Y_offset = 5;

        // Directions for maze generation (North, South, East, West)
        const directions = [
            { x: 0, z: -1 }, // North
            { x: 0, z: 1 },  // South
            { x: 1, z: 0 },  // East
            { x: -1, z: 0 }  // West
        ];

        const miniMapCanvas = document.getElementById('miniMap');
        const miniMapContext = miniMapCanvas.getContext('2d');
        const playerCoordsDiv = document.getElementById('playerCoords');
        const playerAngleDiv = document.getElementById('playerAngle');
        const collisionTextDiv = document.getElementById('collisionText');
        const levelTextDiv = document.getElementById('levelText');
        let maze;

        // Initialize scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // PointerLockControls for first-person view
            controls = new THREE.PointerLockControls(camera, document.body);
            document.addEventListener('click', () => controls.lock());

            scene.add(controls.getObject());

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff);
            scene.add(ambientLight);

            // Floor
            const textureLoader = new THREE.TextureLoader();
            const floorTexture = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(8, 8);  // Adjust this value to change the pattern size

            const floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
            const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.set((mazeWidth * cellSize) / 2 - cellSize / 2, 0, -(mazeHeight * cellSize) / 2 + cellSize / 2);
            scene.add(floor);

            // Load wall texture
            const wallTexture = textureLoader.load('https://threejs.org/examples/textures/brick_diffuse.jpg');
            wallTexture.wrapS = THREE.RepeatWrapping;
            wallTexture.wrapT = THREE.RepeatWrapping;
            wallTexture.repeat.set(0.5, 0.5);

            // Generate and add maze walls
            maze = generateMaze(mazeWidth, mazeHeight);
            addMazeToScene(maze, wallTexture);

            // Set the player's starting position to the center of the 5x5 section and move up vertically
            const centerX = Math.floor(mazeWidth / 2) * cellSize;
            const centerZ = -Math.floor(mazeHeight / 2) * cellSize;
            camera.position.set(centerX, 5, centerZ); // Increase the y value to move the player up

            // Draw the static 2D representation of the maze
            drawMiniMap(maze);

            // Spawn enemies for the current level
            spawnEnemiesForLevel(currentLevel);

            // Animate the scene
            animate();
        }

        // Generate maze using depth-first search algorithm
        function generateMaze(width, height) {
            const maze = Array.from({ length: height }, () => Array(width).fill(1));
            const stack = [];
            const start = { x: 0, z: 0 };

            maze[start.z][start.x] = 0;
            stack.push(start);

            while (stack.length > 0) {
                const current = stack.pop();
                const neighbors = getUnvisitedNeighbors(current, maze);

                if (neighbors.length > 0) {
                    stack.push(current);

                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[(current.z + next.z) / 2][(current.x + next.x) / 2] = 0;
                    maze[next.z][next.x] = 0;

                    stack.push(next);
                }
            }

            // Ensure the middle 5x5 section has no walls
            const centerX = Math.floor(width / 2);
            const centerZ = Math.floor(height / 2);
            for (let z = centerZ - 2; z <= centerZ + 2; z++) {
                for (let x = centerX - 2; x <= centerX + 2; x++) {
                    maze[z][x] = 0;
                }
            }

            // Add more gaps in the maze walls
            addGapsToMaze(maze);

            return maze;
        }

        // Add more gaps in the maze walls
        function addGapsToMaze(maze) {
            const additionalGaps = Math.floor((mazeWidth * mazeHeight) / 10); // Adjust this value as needed
            for (let i = 0; i < additionalGaps; i++) {
                const x = Math.floor(Math.random() * mazeWidth);
                const z = Math.floor(Math.random() * mazeHeight);
                maze[z][x] = 0;
            }
        }

        // Get unvisited neighbors
        function getUnvisitedNeighbors(cell, maze) {
            const neighbors = [];

            for (const direction of directions) {
                const nx = cell.x + direction.x * 2;
                const nz = cell.z + direction.z * 2;

                if (nx >= 0 && nx < maze[0].length && nz >= 0 && nz < maze.length && maze[nz][nx] === 1) {
                    neighbors.push({ x: nx, z: nz });
                }
            }

            return neighbors;
        }

        // Add maze walls to the scene
        function addMazeToScene(maze, wallTexture) {
            const wallGeometry = new THREE.BoxGeometry(cellSize, 10, cellSize);
            const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture });

            for (let z = 0; z < maze.length; z++) {
                for (let x = 0; x < maze[z].length; x++) {
                    if (maze[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x * cellSize, 5, -z * cellSize);
                        wall.userData.isWall = true; // Marking wall objects
                        wall.userData.boundingBox = new THREE.Box3().setFromObject(wall); // Add bounding box
                        scene.add(wall);
                        objects.push(wall);
                    }
                }
            }
        }

        // Draw the static 2D representation of the maze
        function drawMiniMap(maze) {
            const miniMapScaleX = miniMapCanvas.width / (mazeWidth * cellSize);
            const miniMapScaleY = miniMapCanvas.height / (mazeHeight * cellSize);

            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            miniMapContext.fillStyle = 'white';
            
            for (let z = 0; z < maze.length; z++) {
                for (let x = 0; x < maze[z].length; x++) {
                    if (maze[z][x] === 1) {
                        miniMapContext.fillRect(x * cellSize * miniMapScaleX, z * cellSize * miniMapScaleY, cellSize * miniMapScaleX, cellSize * miniMapScaleY);
                    }
                }
            }

            // Draw enemies on the minimap
            miniMapContext.fillStyle = 'blue'; // Color for enemies
            for (const enemy of enemies) {
                const enemyX = (enemy.position.x * miniMapScaleX) + X_offset;
                const enemyZ = (-enemy.position.z * miniMapScaleY) + Y_offset;
                miniMapContext.beginPath();
                miniMapContext.arc(enemyX, enemyZ, 3, 0, 2 * Math.PI); // Smaller radius for enemies
                miniMapContext.fill();
            }
        }

        // Check for collision detection using bounding boxes
        function checkCollision() {
            const playerBoundingBox = new THREE.Box3().setFromCenterAndSize(
                controls.getObject().position,
                new THREE.Vector3(1, 2, 1) // Adjust the size as needed
            );
            const collisionDistance = cellSize * 0.75; // Increase the collision distance threshold

            for (const object of objects) {
                if (object.userData.isWall) {
                    if (playerBoundingBox.intersectsBox(object.userData.boundingBox)) {
                        collisionTextDiv.innerHTML = 'Collision: Yes';
                        return true; // Collision detected
                    }
                }
            }
            collisionTextDiv.innerHTML = 'Collision: No';
            return false; // No collision
        }

        // Add enemies to the scene
        function spawnEnemiesForLevel(level) {
            // Clear existing enemies
            for (const enemy of enemies) {
                scene.remove(enemy);
            }
            enemies.length = 0;

            // Spawn new enemies based on the level
            const enemyCount = level * 5; // Example: 5 enemies per level
            for (let i = 0; i < enemyCount; i++) {
                const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
                const enemyMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
                const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
                // Random position within the maze
                const x = Math.floor(Math.random() * mazeWidth) * cellSize;
                const z = -Math.floor(Math.random() * mazeHeight) * cellSize;
                enemy.position.set(x, 1, z);
                enemy.userData.type = 'zombie';
                scene.add(enemy);
                enemies.push(enemy);
            }
        }

        // Animate function
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateMiniMap();
            updateEnemies();
        }

        // Update the player's position and direction on the mini map and display coordinates
        function updateMiniMap() {
            const miniMapScaleX = miniMapCanvas.width / (mazeWidth * cellSize);
            const miniMapScaleY = miniMapCanvas.height / (mazeHeight * cellSize);

            // Clear the previous player position
            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            drawMiniMap(maze);

            // Draw the player position and direction
            miniMapContext.fillStyle = 'red';
            const playerX = (controls.getObject().position.x * miniMapScaleX) + X_offset;
            const playerZ = (-controls.getObject().position.z * miniMapScaleY) + Y_offset;
            miniMapContext.beginPath();
            miniMapContext.arc(playerX, playerZ, 5, 0, 2 * Math.PI);
            miniMapContext.fill();

            // Correct the player's direction using camera world direction
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            const angle = Math.atan2(direction.x, direction.z);

            // Convert the angle to degrees and adjust the range from 0 to 360
            let angleInDegrees = THREE.MathUtils.radToDeg(angle);
            if (angleInDegrees < 0) {
                angleInDegrees += 360;
            }

            // Draw the player's direction
            const directionX = Math.sin(angle);
            const directionZ = Math.cos(angle);
            miniMapContext.strokeStyle = 'red';
            miniMapContext.beginPath();
            miniMapContext.moveTo(playerX, playerZ);
            miniMapContext.lineTo(
                playerX + directionX * 10,
                playerZ - directionZ * 10
            );
            miniMapContext.stroke();

            // Display the player's actual coordinates and angle
            playerCoordsDiv.innerHTML = `Player Coordinates: X: ${controls.getObject().position.x.toFixed(2)}, Z: ${controls.getObject().position.z.toFixed(2)}`;
            playerAngleDiv.innerHTML = `Player Angle: Y: ${angleInDegrees.toFixed(2)}Â°`;
        }

        // Update enemies
        function updateEnemies() {
            for (const enemy of enemies) {
                if (enemy.userData.type === 'zombie') {
                    // Implement simple AI behavior for zombies
                    moveTowardsPlayer(enemy);
                }
            }
        }

        // Move enemy towards the player
        function moveTowardsPlayer(enemy) {
            const playerPosition = controls.getObject().position;
            const direction = new THREE.Vector3().subVectors(playerPosition, enemy.position).normalize();
            const speed = 0.02; // Adjust speed as needed
            const proposedPosition = enemy.position.clone().add(direction.multiplyScalar(speed));
            
            if (!checkEnemyCollision(proposedPosition)) {
                enemy.position.copy(proposedPosition);
            }
        }

        // Check for collision detection for enemies
        function checkEnemyCollision(position) {
            const enemyBoundingBox = new THREE.Box3().setFromCenterAndSize(
                position,
                new THREE.Vector3(1, 2, 1) // Adjust the size as needed
            );

            for (const object of objects) {
                if (object.userData.isWall) {
                    if (enemyBoundingBox.intersectsBox(object.userData.boundingBox)) {
                        return true; // Collision detected
                    }
                }
            }
            return false; // No collision
        }

        // Level progression function
        function nextLevel() {
            currentLevel++;
            levelTextDiv.innerHTML = `Level: ${currentLevel}`;
            spawnEnemiesForLevel(currentLevel);
        }

        // Key controls
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false,
        };

        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.code] = false;
        });

        // Movement logic
        function move() {
            const speed = 0.1;
            if (keys.KeyW || keys.ArrowUp) {
                controls.moveForward(speed);
                if (checkCollision()) controls.moveForward(-speed); // Undo movement on collision
            }
            if (keys.KeyS || keys.ArrowDown) {
                controls.moveForward(-speed);
                if (checkCollision()) controls.moveForward(speed); // Undo movement on collision
            }
            if (keys.KeyA || keys.ArrowLeft) {
                controls.moveRight(-speed);
                if (checkCollision()) controls.moveRight(speed); // Undo movement on collision
            }
            if (keys.KeyD || keys.ArrowRight) {
                controls.moveRight(speed);
                if (checkCollision()) controls.moveRight(-speed); // Undo movement on collision
            }
        }

        // Start game button
        const startButton = document.getElementById('startButton');
        startButton.addEventListener('click', () => {
            startButton.style.display = 'none';
            init();
            update();
        });

        // Update function
        function update() {
            move();
            requestAnimationFrame(update);
        }
    </script>
</body>
</html>
