<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Maze Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #startButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            font-size: 20px;
            background-color: #000;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #miniMap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #fff;
            background-color: rgba(0, 0, 0, 0.5);
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
</head>
<body>
    <button id="startButton">Start Game</button>
    <canvas id="miniMap" width="150" height="150"></canvas>
    <script>
        // Basic setup
        let scene, camera, renderer, controls;
        const objects = [];

        const mazeWidth = 15; // 50% bigger
        const mazeHeight = 15; // 50% bigger
        const cellSize = 10;

        // Directions for maze generation (North, South, East, West)
        const directions = [
            { x: 0, z: -1 }, // North
            { x: 0, z: 1 },  // South
            { x: 1, z: 0 },  // East
            { x: -1, z: 0 }  // West
        ];

        const miniMapCanvas = document.getElementById('miniMap');
        const miniMapContext = miniMapCanvas.getContext('2d');
        let maze;

        // Initialize scene
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // PointerLockControls for first-person view
            controls = new THREE.PointerLockControls(camera, document.body);
            document.addEventListener('click', () => controls.lock());

            scene.add(controls.getObject());

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff);
            scene.add(ambientLight);

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
            const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x808080 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            scene.add(floor);

            // Generate and add maze walls
            maze = generateMaze(mazeWidth, mazeHeight);
            addMazeToScene(maze);

            // Set the player's starting position to the center of the 5x5 section
            const centerX = Math.floor(mazeWidth / 2) * cellSize;
            const centerZ = -Math.floor(mazeHeight / 2) * cellSize;
            camera.position.set(centerX, 2, centerZ);

            // Draw the static 2D representation of the maze
            drawMiniMap(maze);

            // Animate the scene
            animate();
        }

        // Generate maze using depth-first search algorithm
        function generateMaze(width, height) {
            const maze = Array.from({ length: height }, () => Array(width).fill(1));
            const stack = [];
            const start = { x: 0, z: 0 };

            maze[start.z][start.x] = 0;
            stack.push(start);

            while (stack.length > 0) {
                const current = stack.pop();
                const neighbors = getUnvisitedNeighbors(current, maze);

                if (neighbors.length > 0) {
                    stack.push(current);

                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    maze[(current.z + next.z) / 2][(current.x + next.x) / 2] = 0;
                    maze[next.z][next.x] = 0;

                    stack.push(next);
                }
            }

            // Ensure the middle 5x5 section has no walls
            const centerX = Math.floor(width / 2);
            const centerZ = Math.floor(height / 2);
            for (let z = centerZ - 2; z <= centerZ + 2; z++) {
                for (let x = centerX - 2; x <= centerX + 2; x++) {
                    maze[z][x] = 0;
                }
            }

            return maze;
        }

        // Get unvisited neighbors
        function getUnvisitedNeighbors(cell, maze) {
            const neighbors = [];

            for (const direction of directions) {
                const nx = cell.x + direction.x * 2;
                const nz = cell.z + direction.z * 2;

                if (nx >= 0 && nx < maze[0].length && nz >= 0 && nz < maze.length && maze[nz][nx] === 1) {
                    neighbors.push({ x: nx, z: nz });
                }
            }

            return neighbors;
        }

        // Add maze walls to the scene
        function addMazeToScene(maze) {
            const wallGeometry = new THREE.BoxGeometry(cellSize, 10, cellSize);
            const wallMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });

            for (let z = 0; z < maze.length; z++) {
                for (let x = 0; x < maze[z].length; x++) {
                    if (maze[z][x] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(x * cellSize, 5, -z * cellSize);
                        scene.add(wall);
                        objects.push(wall);
                    }
                }
            }
        }

        // Draw the static 2D representation of the maze
        function drawMiniMap(maze) {
            const miniMapScaleX = miniMapCanvas.width / (mazeWidth * cellSize);
            const miniMapScaleY = miniMapCanvas.height / (mazeHeight * cellSize);

            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            miniMapContext.fillStyle = 'white';
            
            for (let z = 0; z < maze.length; z++) {
                for (let x = 0; x < maze[z].length; x++) {
                    if (maze[z][x] === 1) {
                        miniMapContext.fillRect(x * cellSize * miniMapScaleX, z * cellSize * miniMapScaleY, cellSize * miniMapScaleX, cellSize * miniMapScaleY);
                    }
                }
            }
        }

        // Animate function
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            updateMiniMap();
        }

        // Update the player's position and direction on the mini map
        function updateMiniMap() {
            const miniMapScaleX = miniMapCanvas.width / (mazeWidth * cellSize);
            const miniMapScaleY = miniMapCanvas.height / (mazeHeight * cellSize);

            // Clear the previous player position
            miniMapContext.clearRect(0, 0, miniMapCanvas.width, miniMapCanvas.height);
            drawMiniMap(maze);

            // Draw the player position and direction
            miniMapContext.fillStyle = 'red';
            const playerX = (controls.getObject().position.x + (mazeWidth / 2) * cellSize) * miniMapScaleX;
            const playerZ = (-(controls.getObject().position.z) + (mazeHeight / 2) * cellSize) * miniMapScaleY;
            miniMapContext.beginPath();
            miniMapContext.arc(playerX, playerZ, 5, 0, 2 * Math.PI);
            miniMapContext.fill();

            // Draw the player's direction
            miniMapContext.strokeStyle = 'red';
            miniMapContext.beginPath();
            miniMapContext.moveTo(playerX, playerZ);
            miniMapContext.lineTo(
                playerX + Math.cos(controls.getObject().rotation.y) * 10,
                playerZ + Math.sin(controls.getObject().rotation.y) * 10
            );
            miniMapContext.stroke();
        }

        // Key controls
        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            KeyW: false,
            KeyA: false,
            KeyS: false,
            KeyD: false,
        };

        document.addEventListener('keydown', (event) => {
            keys[event.code] = true;
        });

        document.addEventListener('keyup', (event) => {
            keys[event.code] = false;
        });

        // Movement logic
        function move() {
            const speed = 0.1;
            if (keys.KeyW || keys.ArrowUp) controls.moveForward(speed);
            if (keys.KeyS || keys.ArrowDown) controls.moveForward(-speed);
            if (keys.KeyA || keys.ArrowLeft) controls.moveRight(-speed);
            if (keys.KeyD || keys.ArrowRight) controls.moveRight(speed);
        }

        // Start game button
        const startButton = document.getElementById('startButton');
        startButton.addEventListener('click', () => {
            startButton.style.display = 'none';
            init();
            update();
        });

        // Update function
        function update() {
            move();
            requestAnimationFrame(update);
        }
    </script>
</body>
</html>
